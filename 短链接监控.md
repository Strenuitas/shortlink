# 短链接监控

跳转的同时提供监控信息：访问次数----每跳转一次就记录一次     pv                  pv uv uip 24小时分布  一周访问 记录在t_link_access_stats 基础监控信息    包含gid既然短链接分表了，这个监控信息当然也是要分表的 fullshorturl是因为我们每次请求的时候，要根据这个去查单条记录并增加 以及date  只带年月日  
                        访问人数----根据用户  uv                                  这里我们具体如何设计24小时分布和一周分布 也就是把一周分为 7*24 这样进行记录  
                        IP数--------统计同一IP下访问次数  uip  
                        访问地区----  中国地图 调用高德api   
                        24小时分布--用户访问的时间    
                        高频IP------记录访问次数高的   
                        一周访问----具体周几   
                        操作系统----windows linux macOS   
                        访问浏览器--firefox chrome edge
                        访客类型----分为新老访客   
                        访问网络----wifi 移动数据   
                        访问设备----电脑 移动设备   
# 先做基础访问 pv uv uip 24小时访问 一周访问
# pv访问记录
具体如何进行数据统计呢？   有比较好的方案比如自增 redis里面的increment命令就挺好，但是我们这是使用mysql没有increment命令，可以使用这样 如果某条记录存在  原有基础上加一，如果不存在，设置初始值     
```
INSERT INTO
  t_link_access_stats (
    full_short_url,
    gid,
    date,
    pv,
    uv,
    uip,
    hour,
    weekday,
    create_time,
    update_time,
    del_flag
  )
VALUES(
    'nurl.ink/W5M7a',
    'siCwZo',
    '2023-11-04',
    0,
    0,
    0,
    0,
    0,
    NOW(),
    NOW(),
    0
  ) ON DUPLICATE KEY
UPDATE
  pv = pv + 1,
  uv = uv + 2,
  uip = uip + 3;
```
也就是在跳转的时候会进行统计，拿到跳转的参数也就是ServletRequest ServleResp ，创建DO数据库实体层，然后写Mapper持久层进行数据库的操作，它对应的sql操作会比较麻烦，就选择自己去写对应的sql语句也就是自己去写对应的insert方法，上述sql语句，具体写在代码中就是
```
@Insert(INSERT INTO t_link_access_stats 
(full_short_url, date, pv, uv, uip, hour, weekday, create_time, update_time, del_flag)
VALUES
(#{linkAccessStats.fullShortUrl}, #{linkAccessStats.date}, #{linkAccessStats.pv}, 
 #{linkAccessStats.uv}, #{linkAccessStats.uip}, #{linkAccessStats.hour}, 
 #{linkAccessStats.weekday}, NOW(), NOW(), 0)
ON DUPLICATE KEY UPDATE 
    pv = pv + #{linkAccessStats.pv}, 
    uv = uv + #{linkAccessStats.uv}, 
    uip = uip + #{linkAccessStats.uip};)
void shortLinkStats(@Param("linkAccessStats")LinkAccessStatsDO linkAccessStatsDO);
```
# 这里的#{LinkAccessStats}获取的是传入参数LinkAccessStatsDO这个自动补上字段的DO的字段路径，这是Mybatis的OG功能，Mybati在执行sql之前，会把方法参数解析成一个Map。
大概就是
```
  {
    "linkAccessStats": LinkAccessStats //我自己起的
    "param1": LinkAccessStatsDO       // Mybatis自动生成的
  }
//更具体代码解释
void foo(@Param("a") A a, @Param("b") B b);

//mybatis会生成
{
  "a": A,
  "b": B,
  "param1": A,
  "param2": B
}
//因为无论用不用@Param，都能访问参数
使用@Param访问方式：#{a.xxx} #{b.xxx}
自动生成的访问方式则是:#{param1.xxx}  #{param2.xxx}

//更深层的原因3：底层执行sql时，自动参数绑定统一依赖param1/param2
//这个是MyBatis的最底层的保底机制，框架内部非常依赖这类默认命名参数，保留它能避免修改底层机制，保证所有版本兼容。
```

#  为什么 LinkAccessStatsMapper 需要自己写一个 @Insert 方法？
因为使用了MySQL的特性 INSERT ... ON DUPLICATE KEY UPDATE （简称upsert）。也就是有就更新，没有就插入，这种不是Mybati-plus内置的简单的CRUD可以搞定的功能，因此必须自定义  
SQL，只能写成,正常的比如ShortLinkMapper则是可以选择写在xml文件里或者是写在注解里   
```
@Insert("INSERT INTO xxx ... ON DUPLICATE KEY UPDATE ...")
void shortLinkStats(...)
```

在跳转的时候进行统计也就是在ShortlinkImpl里面写对应的stats方法，先获取当天的周几，再获取指定的小时，


# 短链接uv访问记录
如果用户在不登录的前提下，若同一用户访问短链接多次，如何判断是否为同一用户，使用Cookie的相关知识，用户通过浏览器访问短链接，然后通过短链接跳转原始链接，这里同时返回一个请求响应Cookie,也就是在统计的时候要先获取到用户访问的响应Cookie, 这个Cookie要设置一个过期时间，而且要给Cookie设置path，因为  
Cookie是跟域名挂钩，也就是说不设置path的话，会认为同处在一个域名下的短链接都会识别到同一个用户，这样就乱了，也就是说我们的完整短链接是domain/shorturi  例如  baidu.com/ssskjwq 这样  setPath(StrUtil.sub(fullShortUrl,fullShortUrl.indexOf("/"),fullShortUrl.length));这样就会读取到只有是当前这个短链URi  
才有对应的cookie，防止不同的短链接哪怕是同一用户，也不能串用，所以一个Cookie根据path匹配，对应一个短链对应一个uv Cookie，不过正常一个域名下面会限制Cookie，浏览器正常限制一个域名下面的Cookie为50-150个 如果超过了就会删掉旧的，所以小项目可以用，大规模短链系统不这样用，大平台会只设置一个Cookie，然后  
使用redis记录这个UUID是否访问过某个短链。这个是Cookie的讲解。这时候我们构造了一个设置UV Cookie的任务，这个任务做了3件事，1：为用户生成一个唯一标识(UV),2:把这个UV放进浏览器Cookie，然后把UV写入Redis的Set  Redis Set自动去重，如果第一次访问，会被加入，added为1，若是重复访问，Set里面有了，added为0。  
然后代码接着判断浏览器有没有uv Cookie， 若是Cookie存在，尝试写入Redis，之后若是浏览器根本没有cookie数组，执行上面写好的设置UV Cookie的任务。

同时这里细节：使用了AtomicBoolean 定义uvFirstFlag，因为这个标志位可能在不同线程中被更新，在lambda里面可能在不同线程回调（java规定，lambda可以访问外部变量，但这个变量必须不可重新赋值，使用final修饰，而是用Atomic则是捕获的是uvFirstFlag这个对象的引用，而不是它的值，lambda内部修改对象状态则是合法  的），并发访问标志位时，用普通的boolean不能保证可见性，使用AtomicBoolean确保多线程访问可见性，set/get 操作都是原子性的，不会出现竞态条件。

# 为什么写成Runnable任务而不是普通方法，
讲逻辑分装成任务两个目的 1：抽取重复模块，复用  2：随时可以把它丢到线程池里异步执行，因为我们的跳转 和 统计 判断是否为一个用户，其实是没关系的，未来我们要把他俩异步执行。 这里的执行run()方法类似调用一个方法，没有多线程的参与，

# 短链接ip访问记录
也是一样存入redis， short-link：stats：uip ，如果存在则自增，不存在在加入，类似uv的逻辑。也有对应的uipFirstFlag

# 短链接监控地区， 一般通过网络ip 获取用户所在地区。
要用别的api    https://www.ip-api.com/        支持国内和国外，
               高德地图
