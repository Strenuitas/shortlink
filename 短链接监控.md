# 短链接监控

跳转的同时提供监控信息：访问次数----每跳转一次就记录一次     pv                  pv uv uip 24小时分布  一周访问 记录在t_link_access_stats 基础监控信息    包含gid既然短链接分表了，这个监控信息当然也是要分表的 fullshorturl是因为我们每次请求的时候，要根据这个去查单条记录并增加 以及date  只带年月日  
                        访问人数----根据用户  uv                                  这里我们具体如何设计24小时分布和一周分布 也就是把一周分为 7*24 这样进行记录  
                        IP数--------统计同一IP下访问次数  uip  
                        访问地区----  中国地图 调用高德api   
                        24小时分布--用户访问的时间    
                        高频IP------记录访问次数高的   
                        一周访问----具体周几   
                        操作系统----windows linux macOS   
                        访问浏览器--firefox chrome edge
                        访客类型----分为新老访客   
                        访问网络----wifi 移动数据   
                        访问设备----电脑 移动设备   
# 先做基础访问 pv uv uip 24小时访问 一周访问
具体如何进行数据统计呢？   有比较好的方案比如自增 redis里面的increment命令就挺好，但是我们这是使用mysql没有increment命令，可以使用这样 如果某条记录存在  原有基础上加一，如果不存在，设置初始值     
```
INSERT INTO
  t_link_access_stats (
    full_short_url,
    gid,
    date,
    pv,
    uv,
    uip,
    hour,
    weekday,
    create_time,
    update_time,
    del_flag
  )
VALUES(
    'nurl.ink/W5M7a',
    'siCwZo',
    '2023-11-04',
    0,
    0,
    0,
    0,
    0,
    NOW(),
    NOW(),
    0
  ) ON DUPLICATE KEY
UPDATE
  pv = pv + 1,
  uv = uv + 2,
  uip = uip + 3;
```
也就是在跳转的时候会进行统计，拿到跳转的参数也就是ServletRequest ServleResp ，创建DO数据库实体层，然后写Mapper持久层进行数据库的操作，它对应的sql操作会比较麻烦，就选择自己去写对应的sql语句也就是自己去写对应的insert方法，上述sql语句，具体写在代码中就是
```
@Insert(INSERT INTO t_link_access_stats 
(full_short_url, date, pv, uv, uip, hour, weekday, create_time, update_time, del_flag)
VALUES
(#{linkAccessStats.fullShortUrl}, #{linkAccessStats.date}, #{linkAccessStats.pv}, 
 #{linkAccessStats.uv}, #{linkAccessStats.uip}, #{linkAccessStats.hour}, 
 #{linkAccessStats.weekday}, NOW(), NOW(), 0)
ON DUPLICATE KEY UPDATE 
    pv = pv + #{linkAccessStats.pv}, 
    uv = uv + #{linkAccessStats.uv}, 
    uip = uip + #{linkAccessStats.uip};)
void shortLinkStats(@Param("linkAccessStats")LinkAccessStatsDO linkAccessStatsDO);
```
# 这里的#{LinkAccessStats}获取的是传入参数LinkAccessStatsDO这个自动补上字段的DO的字段路径，这是Mybatis的OG功能，Mybati在执行sql之前，会把方法参数解析成一个Map。
大概就是
```
  {
    "linkAccessStats": LinkAccessStats //我自己起的
    "param1": LinkAccessStatsDO       // Mybatis自动生成的
  }
//更具体代码解释
void foo(@Param("a") A a, @Param("b") B b);

//mybatis会生成
{
  "a": A,
  "b": B,
  "param1": A,
  "param2": B
}
//因为无论用不用@Param，都能访问参数
使用@Param访问方式：#{a.xxx} #{b.xxx}
自动生成的访问方式则是:#{param1.xxx}  #{param2.xxx}

//更深层的原因3：底层执行sql时，自动参数绑定统一依赖param1/param2
//这个是MyBatis的最底层的保底机制，框架内部非常依赖这类默认命名参数，保留它能避免修改底层机制，保证所有版本兼容。
```

#  为什么 LinkAccessStatsMapper 需要自己写一个 @Insert 方法？
因为使用了MySQL的特性 INSERT ... ON DUPLICATE KEY UPDATE （简称upsert）。也就是有就更新，没有就插入，这种不是Mybati-plus内置的简单的CRUD可以搞定的功能，因此必须自定义  
SQL，只能写成,正常的比如ShortLinkMapper则是可以选择写在xml文件里或者是写在注解里   
```
@Insert("INSERT INTO xxx ... ON DUPLICATE KEY UPDATE ...")
void shortLinkStats(...)
```

在跳转的时候进行统计也就是在ShortlinkImpl里面写对应的stats方法，先获取当天的周几，再获取指定的小时，
