短链接业务：  
项目实现了4个服务，分别是用户服务，网关服务，聚合服务以及短链服务也是核心服务，该项目是Sass服务，即用户通过项目所在网站创建用户，自行订阅服务，然后就可创建短链接指向对应的原始长链接。  
核心业务是短链接的跳转，附带上对跳转请求的监控日志，包含但不限于用户设备，网络，位置IP（调用高德地图的api），使用浏览器类型等。同时提供了某个短链接或者是属于用户名下某个短链接分组的统计信息，   
可以清晰查看出用户点击量高的短链接，获取用户喜好，供给算法研究。   

# 用户服务：
有注册用户，查询用户，查询用户无脱敏信息，存储在DB中的数据都是加密的，加密是使用的ShardingSphere的加密算法实现，之后是登录(利用redis的hash数据结构来存储用户的uuid和Info)，检查是否登录，退出用户.   

# 短链接分组
短链接创建：gid 6位随机数，分组标识gid，用户名， 唯一索引则是 gid,username，也就是设置一个分组只能对应一个用户 短链接分组修改：通过分组标识修改name  短链接排序：前端传排序好的然后设置到数据库成为新的排序，因为数据库中存储的是sortOrder和前端的并不一样   

# 短链接管理 核心!!!😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧     
因为后管的流量会少一些，而且我们注册登录完后，响应会返回一个密钥，之后的每次请求header都要带上这个密钥才能继续访问，一般的话我们前端控制台也就是图形化界面不会直接去调我们的短链接服务的接口，一般要通过后管代理，然后由后管去调project服务接  口，也就是后管发请求到短链服务，一般是http请求（用URL调）或者是SpringCloud(基于服务注册中心nacos或Eureka，可负载均衡，微服务架构常用)或者Doubble(性能更高，二进制传输，适合大型分布式，高性能场景，)调用,JWT认证机制，只在前端-后管这层游泳，前端header带上token，后管验证tokcen，再发内部请求给到短链接服务。至于为什么前端控制台不能直接调短链接，因为一来  
这样直接暴露了短链接服务的接口给外部浏览器，容易受到攻击，二来是网络与部署隔离，例如后管的端口8002暴露给外部，而短链接服务监听的8082外网则访问不到，只能通过后管去访问内网，可以把核心业务“藏在后面”，外界无法访问;三的话就是职责划分，前端服务只负责展示和交互，后管服务负责安全校验，短链服务只管业务逻辑(短链生成，跳转，统计，)经典的前后端分离+服务分层架构。  
@JsonFormat是Jackson(Spring Boot默认的JSON序列化库)，提供的注解，作用是java对象与JSON互转时，控制日期类字段的格式化规则。
# 😧😧😧😧😧😧😧😧😧😧😧😧问题1：为什么后管里面要重写一次DTO
后管与短链是两个独立微服务，通过HTTP/Feign传输JSON，因为它们不共享代码，解耦，职责不同。而且是两个独立的Spring Boot工程，分别打包成自己的jar包

# 😧😧😧😧😧😧😧 问题2：为什么这里使用service没有传统意义上的业务层要有一个接口层一个实现层，而是只用Service通过HTTP调用短链服务，
因为这里并不是真正的业务层，只是负责一个调用的功能，暴露给外界的接口是admin服务下面的create接口，而远程调用短链服务的则是内网的接口create，page等，

有个点：后管服务通过Hutool的Http方法调用后端接口，例如HttpUtil.get("url",Map<String,Object> params) 后面的是参数，所以后管拿到的ReqDTO要把参数包装成Map的entry再传送,它会被拼成url/?key1=value1&  
key2=value2,同时Result<IPage<ShortLinkPageRespDTO>> result =
    JSON.parseObject(resultPageStr, new TypeReference<Result<IPage<ShortLinkPageRespDTO>>>() {});这是再调用了短链接服务后拿到的resultPageStr，拿到的肯定是JSon字符串，我们要将它  
反序列化为响应的DTO，如果这样写JSON.parseObject(resultPageStr, Result.class);因为java的泛型在运行时会被类型擦除，泛型嵌套只会读取到最外层的泛型Result，里面的被抹掉了，则要使用TypeReference，  
是Fastjson提供的一个工具类，用来保留泛型信息，这行代码其实是创建了一个匿名内部类，这样Fastjon就能通过反射读取到它的真实泛型类型结构。
java8之前接口里面方法只能有声明，不能实现，8以后接口可以写带方法体的default方法。叫做接口的默认实现。
还有个点：如果手动改了gid在数据库当中，那么这个改了的gid是查询不到对应的短链更不用说数量了，因为，查询短链接分组下的短链数量逻辑是先查询到在这个用户名下的所有短链接分组，也就是获取到一个groupDOList，然而这个用户名上下文仍然是存储的旧的gid的信息，也就是改了gid获取到的groupDOList都不一样了，更不用说
查询到的短链了。
然后最后把远程返回的分组短链数量，按gid匹配到每个分组对象上去  
``` shortLinkGroupRespDTOList.forEach(each -> {
    // 从远程返回的统计结果中，找出 gid 一样的那一条
    Optional<ShortLinkGroupCountQueryRespDTO> first = listResult.getData().stream()
            .filter(item -> Objects.equals(item.getGid(), each.getGid()))
            .findFirst();

    // 如果找到了，就把短链数量设置进去
    first.ifPresent(item -> each.setShortLinkCount(first.get().getShortLinkCount()));
});
```

