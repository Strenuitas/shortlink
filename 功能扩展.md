# 短链接创建时设置默认域名
配置文件里面设置一个默认的域名 shortlink:default:nurl:ink:8001  

# 批量创建短链接
已知客户要创建多个短链接，如果使用单个创建的话会有一个网络上的IO消耗，不是很友好，所以创建一个批量创建的接口供使用    
流程：前端请求将原始链接和标题描述拆分为一个数组，  
```
{
    "domain": "nurl.ink",
    "originUrls": [
        "https://nageoffer.com/",
        "https://nageoffer.com/"
    ],
    "describes": [
        "consequat quis nisi nulla",
        "consequat quis nisi nulla"
    ],
    "gid": "uyCClP",
    "createdType": 1,
    "validDateType": 0
}
``` 
 并且，在创建完短链接后，会返回给前端一个Excel文件，方便用户查看那些原始链接生成了短链接，以及对应短链接是什么？  
整体逻辑：  

<img width="1258" height="519" alt="image" src="https://github.com/user-attachments/assets/c3001d6c-4a75-4eb7-90ec-30785d1cac56" />
至于为什么短链接中台返回标准数据，后管返回Excel
因为短链接中台是提供通用能力的中台，供许多客户端系统使用，不只是短链接后管，应该返回公共的返回参数，因为有些客户端不需要Excel流处理，如果要个性化定制，后管就只需返回公共的参数即可。   

# 修改短链接的功能扩展
即 如果修改了短链接的有效期类型或者有效期时间，采用的办法是先更新数据库，再进行缓存删除（如果修改了有效期时间和有效期类型都要先删除跳转的缓存，goto，有bug就是如果恢复了不能跳转了，就要做到把对应的isnull给删掉。也就是原来的记录是失效的，改成有效的 即 永久或者是在当前时间后再过期，就把isnull对应的给删  掉。这样重新加载的时候也会自动存储一个goto的key）。也是比较常用的适合并发量并不是过大的场景，除非是秒杀的场景下就要考虑订阅数据库变更日志binlog再操作缓存，或者使用阿里提供的canal中间件，把canal会自动把数据库变更日志投递给     
下游的消息队列，消息队列是有稳定的可靠性的，可以一直重试，再更新缓存。

# 风控问题，部署的saas应用公网上应用，即设置跳转链接的白名单的设置，即有些网站
这里没有设置Spring @Value注解去读，而是先写一个配置类，注入到impl，也就是创建和修改短链接的时候，先去验证域名是不是属于这个类里面（具体有映射的操作）

#  登录的时候允许多端登录。
登录的时候返回一个token，同时设置登录有效期为30min

# 创建短链接分组的限制问题
限制一个用户下面20个分组，因为我们我们是作为分布式应用去部署的，那么普通的synchronized和ReentrantLock就不可以了，所以我们要使用分布式锁去做全局管控，利用conut1的形式判断分组数量，如果小于20个可以继续创建，
具体先是redission的getLock，设置锁的名称与用户挂钩，然后lock.lock()也就是锁住，其他请求只能获取到锁才能进行分组的创建，接下来就是try,lock因为有限制分组，也就是  
主动抛出异常即创建的分组数为20个了以后，提示分组数已经够了，不能继续接下来的创建，即先拿这个用户名去查对应的分组，然后使用baseMapper的selectList获取到分组的  
数量，然后判断即可。

# 关于Saas应用部署到公网，如何避免别人的攻击
首先是流量控制，
    后管：根据登录用户做出控制，比如1s请求后管系统频率最多x次，超过x次请求失败，也就是设置一个时间窗口，判断这个时间段内的请求数量，我们可以使用redis的increment命令对这个数据进行递增，如果超过x次就返回失败。窗口期可以进行设置，但是increment命令需要设置对应数据的过期时间的，即首先要创建一个increment命令，如果请求第一次进来就会创建对应的key，这个是原子的，这时候同时需要设置过期时间为1s，之后的请求就要包括在这个1s的窗口期，这个是原子的，新增完之后我们要给他设置对应的过期逻辑，这个就是两步非原子的，在高并发的场景下，如果进来一个请求，设置了key之后还没来得及设置过期时间就有新的请求进来，那INCR会  
    累加，但是过期时间没有设置，这个计数会一直存在，导致窗口失效，极端一点就是1ms中进来了大量的请求，这个时间全都用来创建key然后incr增加，且没有设置过期时间，那么我们这个流量控制就无从谈起了，因此要把设置key，同时再设置过期时间设置为原子的，如果一步失败，推到重来。
    脚本返回的数值是默认是long类型的。
    这个流量控制依赖于过滤器的，全局拦截它的所有请求，然后加载脚本。之前有一个用户信息过滤器，登陆之后，会把用户信息放到UserContext上下文里面，每个过滤器之间是一条链路，就是责任链模式的一种实践，链路就有顺序，把用户信息存储到上下文这个过滤器设置为0，之后风控过滤器可以设置为10，一般都会设置一个步长10  或者100 ，这样方便我们后面可以在中间加其他的过滤器直接从上下文里面获取到username，
    。这个过滤器是new出来的，不同于其他的bean，所以从配置文件里面获取参数的时候不一样。

# 在中台里面也可以实现流量风控
在某个接口设置一个限定值，超过就报错，一个接口最大接受20qps超过就限流或者降级，自己写比较麻烦，可以使用阿里巴巴的SpringCloud生态的Sentinal来实现流量控制，主要以流量为切入点，从流量控制，流量路由，熔断降级，系统自适应保护几个维度帮助用户保障微服务的稳定性。简单来说给服务或者接口，Sentinal官方叫做资  源设置一个上限值，如果超过这个上限值，它可以直接把请求掐断掉，或者是降级，比方说调用一个接口需要使用多个服务组装数据，降级就是他可以给你返回一个静态的数据就会减小系统的负载量。C端要有个流控这种东西，Sentinal这个架构学习很有必要。混沌工程：模拟服务宕机，模拟网速限制，模拟异常情况来实验系统稳定性以  
应对真实的复杂情况。
Sentinal 定义规则一般两种:代码里面定义和控制台定义，后者是在分布式情况下多一点。先按限制规则，setGrade(RuleConstant,FLOW_GRADE_QPS/FLOW_GRADE_THREAD)两种限制规则，一种qps一种线程数，注解就是@SentianlResource规则写在对应的接口上。
测试的话我们可以进行压力测试，使用jmeter进行压测。压测的时候如果写1s内执行100个线程，会出现两个或多个请求成功，其他的返回被Sentinal熔断降级后的返回值，因为机器性能不足可能1s执行不玩，然后就会执行2s，就会有多个线程成功执行。


# 消息队列重构短链接监控工呢 ！！！！😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧😧重要
初始的是跳转之后同步记录统计信息，这样的话如果海量访问短链接直接访问数据库，会把数据库打穿，因此需要引入消息队列削峰，轻量级的应用，能不引组件就不引，所以选用Redis充当消息队列
2.Redis实现消息队列的集中方式：List PubSub Stream，前两者能实现功能，但是缺少一些模型，比如说ACK和消费者组，redis在2018年开发的新的数据结构Steam，支持对应的ACK和消费者组。整体的逻辑为：

<img width="981" height="502" alt="短链接跳转监控统计消息队列异步流程图" src="https://github.com/user-attachments/assets/ea01801d-5474-443b-be5c-d8c1cce0ef82" />
存储到数据库之后会返回ACK

# 创建Redis Stream Key相关配置
1:创建Stream key
```Shell
XADD "short_link:stats-stream" * "New key" "New value"  
```
2:创建消费者组
```Shell
xgroup create short_link:stats-stream short_link:stats-stream:only-group 0
```

