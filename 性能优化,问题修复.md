# 分布式锁创建短链接 vs 布隆过滤器创建
首先先把sentinal下线，分布式锁创建会强制将并行转成串行，一开始都很慢，我就去寻找原因，是否是数据库新增比较慢，然后把它注释掉，或者是其他资源的调用也费时间，然后各种注释去试，  
发现获取图标有问题，因为它是要发送网络请求获取图标的，  所以我们可以在创建的时候同时获取到图标，然后新增的时候直接去拿到就可以而并发把这个任务放在后面。

# 用户注册 并发请求异常提示
如果是没有新增成功，提示新增异常，如果是唯一索引冲突，提示用户名已存在异常，  区分两种异常，便于后续排查问题。也就是我们的逻辑就是如果两个相同的注册用户名的请求进来，我们第一个拿到锁，它大概率是不会失败的，因此我们第二个获取不到所的异常直接抛已存在异常，节省响应时间。

# 每个请求都分配一个线程
而这个线程是属于SpringBoot的tomcat容器提供的tomcat线程池提供的线程去访问业务， 正常线程池是先使用核心线程然后放阻塞队列，然后再去创建最大线程数，也就是使用剩下的线程，tomcat为了提高请求响应速度和并发处理能力，它将阻塞队列和最大线程数调换了位置，最大线程数是有限制的，如果超过这个限制，剩下请求要放到  
阻塞队列，假设我们接口处理能力（响应时间）1000ms，200个用户同时请求，我们吞吐量就是200，如果201个请求同时来访问，第201个请求响应时间则是2000ms，根据之前读写锁设计，也就是修改信息的时候写锁被获取，假如300ms，所有的访问短链接就会被阻塞300ms，如果很热的一个短链接访问量并发量特别大，那么有可能线程池  
最大线程数用完之后，还会剩下很多的请求堆积在阻塞队列里面，这个阻塞队列是无界的，如果堆积的特别多的话，可能会出现OOM,所以我们这时候引入了延迟队列，也就是不等待读锁，跳转逻辑我们是直接到redis里面去寻找的，不牵涉读写锁，把统计监控的任务放进延迟队列里面，等待修改完成再记录。但是后面我们又因为想优化用户  
体验而设置了跳转与统计的异步，也就是统计监控任务我们扔到了消息队列里，如果写锁已经被获取了，那么最大可能也就是消费者组的比方说10个消费者线程全部等待读锁，之后的统计监控任务则会继续堆积在消息队列里面，也不会出现OOM的情况，因此此时延迟队列的作用就显得没那么大了，相当于我们MQ消费者线程正常阻塞的时间  
平替了延迟队列的延迟消费的时间。而且也解决了OOM的问题。  
统计监控信息业务不再使用trylock而是lock()即如果获取不到锁一直阻塞，阻塞的线程也是处在消费者组的那些线程，其余的统计监控信息任务会继续堆积在消息队列里面，因此不会导致OOM。
# 修改短链接获取写锁
如果短链接一直被访问，那么写锁会不会一直获取不到，在没有引入rocketMQ的时候，如果短链接一直在被访问，我们使用lock()获取写锁，它会一直获取不到锁，用户点一下修改，他就会一直转圈圈因此我们设置为trylock即时响应(当前短链接使用量大，请稍后修改);但是在之后当我们引入rocketMQ的时候，消费者组的请求都是固定的，  
我们进入一个写的请求，设置为lock()就让他一直等待就好了，读锁只要释放了就会轮到写锁。

我对 RReadWriteLock 做了一个测试，就是虽然 RReadWriteLock 不支持公平锁，但是每次读线程 readLock.lock() 获取读锁的时候，其实会检查锁同步队列的队头是否是一个写线程在等待，如果是的话，那么读线程会直接进入锁同步队列等待，因此这里写线程其实是可以避免被读线程不断插队的。
但前提是你获取读锁的时候用的是 readLock.lock()，如果你用的是 readLock.tryLock()，那么读线程将不会检查锁同步队列的队头，而是直接加读锁，导致写线程被不断插队。
在 Redisson 的 RReadWriteLock 中，如果你用的是 readLock.tryLock()，读锁更容易“插队”成功，从而导致写锁一直得不到执行。  
Redisson 的读写锁不是公平锁。

为了避免常见的“写锁饿死”问题，它做了一个优化（虽然不是公平锁的完整语义，但目的类似）：
# 当读线程使用 readLock.lock() 时：
Redisson 内部会：

检查等待队列的头节点是否是写锁请求（write thread）

若是写锁等待，则 读锁不会获得锁，会被挂起等待，让写锁优先执行
        好处：写锁不会被大量读锁饿死。
# 但当读线程使用 readLock.tryLock() 时
tryLock 是“试试看”：

不检查队列里是否有写线程等待

只检查：

当前没有写锁持有（持有！不是等待！）

如果写锁只是等待，但没真正持有锁 → tryLock 依然会直接成功。

结果就是：

🔥 tryLock 的读线程会疯狂插队，导致写线程永远拿不到锁。
这个和 JDK 的 ReentranReadWriteLock 是同一个道理，区别在于 RReadWriteLock 只实现了非公平锁，但是在这个锁并发度不高的场景下已经足够避免写线程长时间饥饿了。  
<img width="904" height="571" alt="image" src="https://github.com/user-attachments/assets/60967bdd-a9c6-40a3-81da-97f4ae01ee00" />
