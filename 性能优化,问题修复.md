# 分布式锁创建短链接 vs 布隆过滤器创建
首先先把sentinal下线，分布式锁创建会强制将并行转成串行，一开始都很慢，我就去寻找原因，是否是数据库新增比较慢，然后把它注释掉，或者是其他资源的调用也费时间，然后各种注释去试，  
发现获取图标有问题，因为它是要发送网络请求获取图标的，  所以我们可以在创建的时候同时获取到图标，然后新增的时候直接去拿到就可以而并发把这个任务放在后面。

# 用户注册 并发请求异常提示
如果是没有新增成功，提示新增异常，如果是唯一索引冲突，提示用户名已存在异常，  区分两种异常，便于后续排查问题。也就是我们的逻辑就是如果两个相同的注册用户名的请求进来，我们第一个拿到锁，它大概率是不会失败的，因此我们第二个获取不到所的异常直接抛已存在异常，节省响应时间。

# 每个请求都分配一个线程
而这个线程是属于SpringBoot的tomcat容器提供的tomcat线程池提供的线程去访问业务， 正常线程池是先使用核心线程然后放阻塞队列，然后再去创建最大线程数，也就是使用剩下的线程，tomcat为了提高请求响应速度和并发处理能力，它将阻塞队列和最大线程数调换了位置，最大线程数是有限制的，如果超过这个限制，剩下请求要放到  
阻塞队列，假设我们接口处理能力（响应时间）1000ms，200个用户同时请求，我们吞吐量就是200，如果201个请求同时来访问，第201个请求响应时间则是2000ms，根据之前读写锁设计，也就是修改信息的时候写锁被获取，假如300ms，所有的访问短链接就会被阻塞300ms，如果很热的一个短链接访问量并发量特别大，那么有可能线程池  
最大线程数用完之后，还会剩下很多的请求堆积在阻塞队列里面，这个阻塞队列是无界的，如果堆积的特别多的话，可能会出现OOM,所以我们这时候引入了延迟队列，也就是不等待读锁，把它放进延迟队列里面，
<img width="904" height="571" alt="image" src="https://github.com/user-attachments/assets/60967bdd-a9c6-40a3-81da-97f4ae01ee00" />
