# 分布式锁创建短链接 vs 布隆过滤器创建
首先先把sentinal下线，分布式锁创建会强制将并行转成串行，一开始都很慢，我就去寻找原因，是否是数据库新增比较慢，然后把它注释掉，或者是其他资源的调用也费时间，然后各种注释去试，  
发现获取图标有问题，因为它是要发送网络请求获取图标的，  所以我们可以在创建的时候同时获取到图标，然后新增的时候直接去拿到就可以而并发把这个任务放在后面。

# 用户注册 并发请求异常提示
如果是没有新增成功，提示新增异常，如果是唯一索引冲突，提示用户名已存在异常，  区分两种异常，便于后续排查问题。也就是我们的逻辑就是如果两个相同的注册用户名的请求进来，我们第一个拿到锁，它大概率是不会失败的，因此我们第二个获取不到所的异常直接抛已存在异常，节省响应时间。

# 每个请求都分配一个线程
而这个线程是属于SpringBoot的tomcat容器提供的tomcat线程池提供的线程去访问业务， 正常线程池是先使用核心线程然后放阻塞队列，然后再去创建最大线程数，也就是使用剩下的线程，tomcat为了提高请求响应速度和并发处理能力，它将阻塞队列和最大线程数调换了位置，最大线程数是有限制的，如果超过这个限制，剩下请求要放到  
阻塞队列，假设我们接口处理能力（响应时间）1000ms，200个用户同时请求，我们吞吐量就是200，如果201个请求同时来访问，第201个请求响应时间则是2000ms，根据之前读写锁设计，也就是修改信息的时候写锁被获取，假如300ms，所有的访问短链接就会被阻塞300ms，如果很热的一个短链接访问量并发量特别大，那么有可能线程池  
最大线程数用完之后，还会剩下很多的请求堆积在阻塞队列里面，这个阻塞队列是无界的，如果堆积的特别多的话，可能会出现OOM,所以我们这时候引入了延迟队列，也就是不等待读锁，跳转逻辑我们是直接到redis里面去寻找的，不牵涉读写锁，把统计监控的任务放进延迟队列里面，等待修改完成再记录。但是后面我们又因为想优化用户  
体验而设置了跳转与统计的异步，也就是统计监控任务我们扔到了消息队列里，如果写锁已经被获取了，那么最大可能也就是消费者组的比方说10个消费者线程全部等待读锁，之后的统计监控任务则会继续堆积在消息队列里面，也不会出现OOM的情况，因此此时延迟队列的作用就显得没那么大了，相当于我们MQ消费者线程正常阻塞的时间  
平替了延迟队列的延迟消费的时间。而且也解决了OOM的问题。  
统计监控信息业务不再使用trylock而是lock()即如果获取不到锁一直阻塞，阻塞的线程也是处在消费者组的那些线程，其余的统计监控信息任务会继续堆积在消息队列里面，因此不会导致OOM。
# 修改短链接获取写锁
如果短链接一直被访问，那么写锁会不会一直获取不到，在没有引入rocketMQ的时候，如果短链接一直在被访问，我们使用lock()获取写锁，它会一直获取不到锁，用户点一下修改，他就会一直转圈圈因此我们设置为trylock即时响应(当前短链接使用量大，请稍后修改);但是在之后当我们引入rocketMQ的时候，消费者组的请求都是固定的，  
我们进入一个写的请求，设置为lock()就让他一直等待就好了，读锁只要释放了就会轮到写锁。

我对 RReadWriteLock 做了一个测试，就是虽然 RReadWriteLock 不支持公平锁，但是每次读线程 readLock.lock() 获取读锁的时候，其实会检查锁同步队列的队头是否是一个写线程在等待，如果是的话，那么读线程会直接进入锁同步队列等待，因此这里写线程其实是可以避免被读线程不断插队的。
但前提是你获取读锁的时候用的是 readLock.lock()，如果你用的是 readLock.tryLock()，那么读线程将不会检查锁同步队列的队头，而是直接加读锁，导致写线程被不断插队。
在 Redisson 的 RReadWriteLock 中，如果你用的是 readLock.tryLock()，读锁更容易“插队”成功，从而导致写锁一直得不到执行。  
Redisson 的读写锁不是公平锁。

为了避免常见的“写锁饿死”问题，它做了一个优化（虽然不是公平锁的完整语义，但目的类似）：
# 当读线程使用 readLock.lock() 时：
Redisson 内部会：

检查等待队列的头节点是否是写锁请求（write thread）

若是写锁等待，则 读锁不会获得锁，会被挂起等待，让写锁优先执行
        好处：写锁不会被大量读锁饿死。
# 但当读线程使用 readLock.tryLock() 时
tryLock 是“试试看”：

不检查队列里是否有写线程等待

只检查：

当前没有写锁持有（持有！不是等待！）

如果写锁只是等待，但没真正持有锁 → tryLock 依然会直接成功。

结果就是：

🔥 tryLock 的读线程会疯狂插队，导致写线程永远拿不到锁。
这个和 JDK 的 ReentranReadWriteLock 是同一个道理，区别在于 RReadWriteLock 只实现了非公平锁，但是在这个锁并发度不高的场景下已经足够避免写线程长时间饥饿了。  
<img width="904" height="571" alt="image" src="https://github.com/user-attachments/assets/60967bdd-a9c6-40a3-81da-97f4ae01ee00" />

# 线上部署一段时间后 跳转记录不生效

streampollTask 一直去stream里面拿消息，它提示records为空，因为它for循环底层是调用list迭代器的方法，如果records为空的话，它返回就会抛异常，就会抛一系列链接不到redission的异常，我就以为是springboot依赖版本的问题，为此我去查询了最新版本，升级到3.2.4也没有，我以为会加一个非空判断，之后发现它有一个函数  
返回值既可以使用spring去做也可以使用redission使用，因此是一个多态的实现，因此我把redission的版本迭代，发现就解决了问题。这种空指针的异常不太好找，我先去redission的issue里面没有发现类似的异常，我又想他可能与spring data redis有关，因此去搜索spring-boot的issue，也没有找到。然后去搜索谷歌访问类似的  
异常，然后我就试着把版本升级。如果前两把种方法都不行的话 只能去看源码去解决了。

# 监控优化
如果我们短链接迁移分组，所有的监控信息都要变更，因此我们把监控表里的gid删掉，之前的话我们查询监控数据，只需查一张监控信息表就可以了，然后通过它的gid去查询指定的分组，现在去掉后，因此引入t_link走一个inner join 的形式，gid去t_link里去筛查，其他的去监控信息表里去筛查，两者实现一个互补。因此我们把  
today里的today也删掉，同时也不再分表，因为不存在gid字段而是用gid分表 会产生一个笛卡尔积，因此不在分表又引入了新的问题就是一个表存储的数据会越来越大怎么办，我们可以采用一种方案：冷热分离，我们要用的只是今日的数据，如果是之前历史的用不到的我们将它迁移到today_back表里去。我们可以设置一个定时任务  
让他存一个月的揭露，超过一个月记录定时迁移到back表里面。因此today里的都是热数据。

# 队列消费需要读取最新gid
监控逻辑的发送者是有发送gid的，即如果缓存失效的时候会去数据库里去查找并拿到短链接的信息包括gid，如果这时候有访问该短链接的请求进来，但是被一个写锁堵塞，因为我们使用的是lock()会被阻塞，直到写锁释放，我们这个消息才能被消费，如果写入修改了gid，那么我们消费者消费的时候也就是记录监控持久化到数据库  
的时候是带着旧的gid的，因此就不可以，所以我们采取的方案即所有的客户端传gid取消，转而让我们消费者实时去查gid，因为我们MQ的消费逻辑，线程数是固定的，因此不会出现大量的查询数据库的场景。
# 保证不同分组下短链唯一
我们在goto表里面设置的唯一索引，goto表通过fullshorturl查对应的gid的，因此我们在这里加上唯一索引也就不会有不同分组下的短链冲突。
# lua脚本
设置不存在key则新增设置过期时间，如果存在key则不刷新过期时间。

# 横向越权，
用户A可以访问用户B名下的短链接数据，因此我们在访问短链接监控数据时，需要确认短链接属于用户所有。因此总的思想可以是：全局gid唯一，
但是现在有个问题，Gid 是用户下唯一，咱们短链接表里仅存储了短链接分组 Gid，相当于两个用户下可能有一样的 Gid。这样的话，我们就不能通过 t_link 表判断短链接归属用户所有。  
解决方案如下：  
● 在短链接 t_link 表中添加用户名 username 字段，通过两个字段一起判断。  
● 🌟 设置分组标识 Gid 全局唯一。  
### 1.修改 t_group 唯一索引
需要通过数据库唯一索引兜底，之前通过 t_group 表无法兜底，因为按照 username 分表的话，可能两个用户创建了一样的 gid，结果存储到两个表里，就无法进行兜底了。
为此，我们创建 t_group_unique 表单独创建个 gid 唯一索引进行兜底。  
### 2.设置分组标识 Gid 全局唯一
之前是通过用户名 username 和分组标识 Gid 一起判断是否重复，现在修改为 Gid 单独控制。

## 关于用户查询权限校验有两个说法，一个是 admin、project 都校验，一个是在 project 项目校验，关于这两个聊下优缺点：   
● admin、project 都校验：如果用户访问越权，直接在第一层拦截住，就避免了 project 无用调用。缺点是如果用户没有越权，会多一次 admin 检查性能。  
● project 校验：如果用户访问越权，会多一层无效调用。优点是用户没有越权，少一次 admin 检查性能。    
综合考虑，最终选择了 project 检验，因为我们做系统面临用户正常访问和不正常访问两种情况和性能挂钩时，尽量选择相信用户。如果是检验 Redis 的话，我就倾向于 admin、project 都校验。  
四个监控方法里在业务方法执行前检查分组标识是否属于用户。  
这里有个小问题，UserContext 是在后管中才有的，我们通过后端系统调用 Project，是获取不到用户登录信息，如何获取当前用户？    
● 通过参数形式传递：如果用户直接调用 Project 监控接口，可以伪造用户名。  
● OpenFeign 透传用户登录信息。  
创建 OpenFeign 请求透传信息 Bean，并获取当前登录用户信息，传递到调用 Project 项目的网络请求中。  
远程调用 OpenFeign 接口指定配置类。
```
@FeignClient(
        value = "short-link-project",
        url = "${aggregation.remote-url:}",
        configuration = OpenFeignConfiguration.class
)
public interface ShortLinkActualRemoteService {
}
```  
通过这种方案，我们就可以在 Project 项目中创建拦截器设置用户上下文。  
后管项目中用的是过滤器，这里可以尝试下拦截器.  
```
import cn.hutool.core.util.StrUtil;
import jakarta.annotation.Nullable;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

/**
 * 用户信息传输拦截器
 */
@Component
public class UserTransmitFilter implements HandlerInterceptor {

    @Override
    public boolean preHandle(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Object handler) throws Exception {
        String username = request.getHeader("username");
        if (StrUtil.isNotBlank(username)) {
            String userId = request.getHeader("userId");
            String realName = request.getHeader("realName");
            UserInfoDTO userInfoDTO = new UserInfoDTO(userId, username, realName);
            UserContext.setUser(userInfoDTO);
        }
        return true;
    }

    @Override
    public void afterCompletion(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Object handler, Exception exception) throws Exception {
        UserContext.removeUser();
    }
}
```
